\chapter{Приложения и система: низкий уровень}

О низком уровне абстракции незримом, но важном.

\section{ABI и системные вызовы}
\subsection{ABI}
\begin{definition}
API~--- Application Programming Interface.
Не вдаваясь в подробности, можно считать, что это тот интерфейс, который видит разработчик.
\end{definition}
С API программисты встречаются ежедневно, в этом вопросе есть какие-то особенности, связанные с конкретными языками программирования (полиморфизм, инстанциация шаблонов, \dots), но в курсе <<операционных систем>> нас это не очень интересует.

\begin{definition}
ABI~--- Application Binary Interface.
В отличии от API, ABI~--- это интерфейс, который интересует разработчиков компиляторов, ядер операционных систем и низкоуровневых библиотек.

В ABI входят:
\begin{itemize}
    \item конвенции вызовов (C, Pascal, stdcall, fastcall, \dots);
    \item соглашения о размещении данных в регистрах;
    \item соглашения о выравниваниях;
    \item организация переключений уровней привилегий, методы организации системных вызовов;
    \item соглашения о линковке;
    \item другие специфичные для текущей архитектуры вещи.
\end{itemize}
\end{definition}

Пройдёмся по перечисленному списку.

Конвенции вызовов~--- это правила, описывающие в каком порядке следует складывать аргументы вызываемой процедуры на стек и/или в регистры процессора, например, в стандартной конвенции языка C аргументы складываются на стек в обратном порядке, а семейство конвенций fastcall старается положить как можно больше аргументов в регистры процессора, а те, что не поместились~--- на стек.

Соглашения о размещении данных в регистрах обычно диктуются архитектурой процессора (например, на x$86_{32}$ многие арифметические операции размещают результаты вычислений в строго определённых регистрах) и необходимостью обратной совместимости с неподдерживаемым (legacy) кодом.

Где-то между конвенциями вызовов и соглашениями о размещении данных в регистрах находятся правила, регламентирующие какие регистры при выполнении вызова процедуры должна сохранять вызывающая, а какие~--- вызываемая сторона.

Следующим пунктом идут соглашения о выравниваниях, обычно диктуемые:
\begin{itemize}
    \item архитектурой железа (например, процессоры ARM вообще не дают возможности обращаться к данным, не выравненным по размеру слова, а при хардварной виртуализации хозяйственные структуры данных обычно требуется размещать выравненными по размеру страницы памяти);
    \item используемыми протоколами;
    \item необходимостью совместимости структур данных с несколькими архитектурами одновременно (например, в системах, где одновременно используются разнородные вычислительные узлы);
    \item \dots
\end{itemize}

Все озвученные выше вопросы нас не очень интересуют, поскольку они должны были быть подробно освещены в курсе по ассемблеру.
Зато оставшиеся пункты говорят о том, что в операционных системах с разделением привилегий требуется реализация механизмов системных вызовов, а при наличии разделяемых библиотек следует договориться о том, как их создавать, подключать и использовать.
Эти два вопроса нас так сильно интересуют, что мы рассмотрим их прямо сейчас.

\subsection{Системные вызовы}
Инструменты, предоставляемые для изоляции процессов друг от друга, могут сильно различаться между архитектурами.
Например, глубокие знания по ассемблеру говорят нам, что (без учёта виртуализации) на процессорах семейства x86 для контекстов исполнения существует четыре уровня привилегий (два бита в селекторе сегмента кода), а на PowerPC~--- всего два.

У разработчиков операционных систем уровни привилегий почему-то принято называть <<кольцами>> (rings) и изображать их как показано на \reffig{rings}.

\begin{empdef}[rings](0.8cm, 1cm) 
    defaultscale := 12pt/fontsize(defaultfont);
    s=w;

    path c,p; c := (-1,0) .. (0,1) .. (1,0) .. (0,-1) .. cycle;
    for i=3 downto 0:
        p := c scaled (s*(i+1));
        fill p withcolor (1,1,1)*(1/5*(5-i)); draw p;
    endfor

    label(btex Ring 0 etex, (0,0));
    label(btex Ring 1 etex, (0,s*(0.4+1)));
    label(btex Ring 2 etex, (0,s*(0.4+2)));
    label(btex Ring 3 etex, (0,s*(0.4+3)));
\end{empdef}

\drawfigureemp{rings}{Уровни привилегий~--- кольца}

При этом считают, что в нулевом кольце (<<Ring 0>>) расположено ядро операционной системы, которому можно всё (читать и писать в любую область памяти, напрямую общаться со всем доступным железом), а в третьем кольце (<<Ring 3>>)~--- приложения пространства пользователя (aka <<userspace>>, <<юзерспейс>>), у каждого из которых нет доступа ни к чему, кроме своей собственной области памяти.
Первое и второе кольцо (как нумеруют промежуточные уровни, если их больше двух~--- я не в курсе) представляют собой какие-то компромиссы между этими двумя крайностями.

В большинстве операционных систем (все UNIX-like, Windows, Haiku/BeOS, \dots) используется только два уровня привилегий~--- ядро vs. юзерспейс, однако существовали и существуют системы, использующие больше (например, OS/2 использует три кольца, а Multics использовала восемь), или вообще использующие только одно кольцо (например, Inferno, Bluebottle).
Популярность двухуровневой модели обусловлена простотой реализации и обширной поддержкой со стороны железа.

Остановимся на этом самом распространённом варианте и взглянем на мир с точки зрения программы, когда её код исполняется процессором в третьем кольце.
Допустим, что этому коду понадобилось прочитать файл с жесткого диска.
Процедуры, связанные с выполнением этой операции, требуют привилегий нулевого кольца для своей работы и находятся где-то в ядре, память которого также защищена от доступа из третьего кольца.
Однако если рассматривать этот факт с точки зрения исполняемого кода, то ему нужно всего лишь на время поднять уровень своих привилегий.
Очевидно, что если разрешить коду самовольно его менять и делать в нулевом кольце всё, что вздумается, то ни о какой <<защищённости>> речи быть не может.
Но если вместе с изменением уровня привилегий исполняемая программа будет передавать управление коду, находящемуся в нулевом кольце, то этот код может проверить, а стоит ли делать то, что его просят, или это может плохо закончиться.

\begin{definition}
Системный вызов (aka <<syscall>>)~--- механизм передачи управления коду с повышенным уровнем привилегий, где вызываемая сторона, если требуется, проверяет легитимность запрашиваемых вызывающей стороной операций.
\end{definition}

Если проверка легитимности требуется, но не производится, или производится не достаточно тщательно, то такой код потенциально подвержен ошибкам нарушения прав доступа (access violation bugs), которые являются, пожалуй, самыми страшными угрозами безопасности системы (особенно для серверов с сервисами, предоставляющими shell-доступ (aka <<удалённый терминал>>) или что-то в этом роде).

Но вернёмся к низкоуровневым механизмам.
На столь любимом x86 существуют аж три метода передачи управления от кода с более низким уровнем привилегий коду в нулевом кольце (для тех, кто не помнит, что всё это значит, их краткие описания приводятся ниже):
\begin{itemize}
    \item Interrupt Descriptor Table (IDT): Trap, Interrupt, Task (TSS);
    \item Global/Local Descriptor Table (GDT/LDT): CallGate;
    \item SYSCALL/SYSENTER.
\end{itemize}
И, как ни странно, все эти механизмы кем-нибудь да используются.
Например, Linux для организации системных вызовов использует прерывания (однако на Pentium IV прерывания работают медленно, и вместо них используется SYSENTER), а FreeBSD использует CallGate.
Не-x86 архитектуры обычно обходятся одними только прерываниями.

Теперь чуть подробнее об использовании упомянутых механизмов.

При использовании прерываний ядро при своей загрузке помещает в IDT дескриптор, обработчик которого представляет собой диспетчер системных вызовов.
Аргументы системного вызова раскладываются вызывающим кодом в порядке, определяемом в соответствии с соглашениями ABI (на x$86_{32}$ это: eax, ebx, ecx, edx, esi, edi).
В первый регистр обычно помещается номер системного вызова, во второй регистр~--- первый аргумент системного вызова, третий регистр~--- второй аргумент, и так далее, однако бывают системные вызовы, которые используют сразу два регистра под номер, а аргументы начинаются с третьего регистра.
Если количество аргументов системного вызова больше, чем доступное количество регистров, то оставшиеся аргументы складываются на стек.

CallGate позволяет создать в адресном пространстве процесса специальную область, при far call на любую ячейку которой будет производится переключение из третьего в нулевое кольцо.
Для приложения весь этот процесс выглядит как обычный вызов процедуры, а для ядра~--- как прерывание (ну почти).

Каждый вызов прерывания требует обращения к памяти, поскольку нужно найти дескриптор в IDT, чтобы достать оттуда сегмент с кодом обработчика.
Инструкции SYSCALL и SYSENTER призваны сэкономить это обращение к памяти, благодаря использованию специальных регистров процессора (aka <<model-specific registers>>, <<MSR>>), в которые ядро при своей загрузке помещает необходимую хозяйственную информацию (селекторы сегментов памяти обработчика системных вызовов).
При этом сами инструкции SYSCALL/SYSENTER просто копируют данные из этих MSR в рабочие регистры.
После этого разница между обработкой прерываний и SYSCALL/SYSENTER исчезает.

Теперь о том, что означает <<обработчик представляет собой диспетчер системных вызовов>>.
В самом начале исполнения обработчика прерывания, вызванного в целях совершения системного вызова, в регистрах процессора записан номер (или номера), идентифицирующий системный вызов, и (возможно не все) его аргументы.
Чтобы суметь разобраться в том, что надо делать, ядро держит в своей памяти таблицу, в которой в n-ной ячейке находится адрес обработчика n-ого системного вызова (кстати, да, системные вызовы нумеруются с единицы).
Обработчик прерывания просто передаёт управление по нужному адресу.

Как упоминалось ранее, может быть так, что первый регистр только указывает семейство системных вызовов, тогда по указанному адресу будет находиться новый диспетчер, руководствующийся в поиске обработчика числом из второго регистра.
Если же был достигнут настоящий обработчик системного вызова, то он смотрит на нужные аргументы в регистрах (и заглядывает на стек, если необходимо), проверяет их корректность, а потом выполняет то, что просят.
В семействе UNIX-like систем принято, что в случае успешного завершения системного вызова в первый регистр (на x$86_{32}$~--- eax) будет помещено какое-то значение $\geq 0$, а если всё плохо, то в этом регистре окажется значение $-$errno, где errno~--- номер ошибки.
Как и с обычными процедурами, после завершения выполнения системного вызова управление будет возвращено на следующую за ним инструкцию.

Какие регистры будут сохранены ядром, а какие должно самостоятельно сохранить вызывающее приложение, опять же, диктуется ABI текущей архитектуры.
На архитектурах, где доступно (относительно) большое количество регистров процессора, иногда просто выделяют <<отрезок>> регистров, зарезервированных ядром.

Поскольку прерывания и другие описанные механизмы требуют использования несколько отличного от работы с обычными процедурами языка C, то для всех (ну почти) системных вызовов стандартная библиотека (libc) предоставляет <<обёртки>>.
Такая обёртка над системным вызовом обычно делает следующее:
\begin{itemize}
    \item сохраняет необходимые регистры процессора, которые могут быть изменены ядром;
    \item раскладывает идентификатор(ы) системного вызова и его аргументы по регистрам и на стек;
    \item вызывает прерывание, делает far call на CallGate или использует инструкции SYSENTER/SYSCALL;
    \item после того как управление будет возвращено, проверяет значение, записанное в первом регистре;
    \item если оно $\geq 0$, то обёртка сама возвращает это значение;
    \item иначе~--- абсолютное значение заталкивается в переменную errno, а результатом вызова процедуры является $-1$.
\end{itemize}

Если системный вызов должен вернуть наружу более одного значения, то, как и с процедурами в языке C, оставшиеся значения будут записаны по соответствующим адресам, переданным в качестве его параметров (aka <<передача по адресу>>).

Рассмотрим один и тот же пример, реализованный на C и на ассемблере.
Реализуем прекрасный <<Hello, world!>> с использованием двух системных вызовов: write и exit.

Системный вызов write записывает данные из буфера в файловый дескриптор, принимая три аргумента:
\begin{itemize}
    \item файловый дескриптор, в который будет производиться запись;
    \item буфер, из которого будет производится запись;
    \item количество байт, которое нужно записать из буфера в файловый дескриптор.
\end{itemize}

Системный вызов exit завершает выполнение программы с кодом (aka <<return value>>, <<\$?>> в bash), указанным в качестве первого и единственного его аргумента.

\begin{ccode}{syscall.c}
void main()
{
    write(1, "Hello, world!\n", 14);
    exit(0);
}

// gcc syscall.c
\end{ccode}

Вообще говоря, можно было бы сделать int типом возвращаемого значения main, и вместо вызова exit использовать обычный return с нужным кодом возврата (а в данном примере даже не меняя типа main заменить exit на return).
Однако эти варианты эквивалентны, поскольку компилятор оборачивает вызов процедуры main служебной процедурой, которая и вызывает exit с результатом процедуры main в качестве аргумента (или с нулём, если main имеет тип void).

Следующее замечание заключается в том, что никакого системного вызова exit не существует, и процедура с таким именем есть только в стандартной библиотеке C.
Системный вызов же носит имя \_exit и его поведение немного отличается от того, что делает процедура exit, но об этих тонкостях речь пойдёт позже (см.~\refsec{syscall:_exit}).

Листинг~\reflst{syscall.S} демонстрирует программу, почти эквивалентную программе~\reflst{syscall.c}, реализованную на ассемблере (в синтаксисе AT\&T).

\begin{asmcode}{syscall.S}
SYS_exit = 1
SYS_write = 4

.data
helloworld: .string "Hello, world!\n"
errno: .4byte

.globl _start
_start:
    movl    $SYS_write,%eax
    movl    $1,%ebx
    movl    $helloworld,%ecx
    movl    $14,%edx
    int     $0x80
    cmp     $0,%eax
    jl      oops
    jmp     ok

    oops:
    mov %eax, errno
    mov $-1, %eax

    ok: # %eax == result, $errno == -errno

    movl    $SYS_exit,%eax
    movl    $0,%ebx
    int     $0x80

# as -o syscall.o syscall.S
# ld syscall.o
\end{asmcode}

Первые две строки объявляют compile-time константы, обозначающие два рассмотренных ранее системных вызова.
После чего начинается секция данных с двумя переменными: буфером со строкой приветствия миру и errno.
Следующая инструкция говорит компилятору, что \_start должна быть меткой, видимой из других единиц трансляции (в терминах C~--- не static процедура).
После этого приведена реализация эквивалента процедура main из предыдущего листинга, с той разницей, что в errno попадает не абсолютное значение ошибки, а отрицательное (из соображений экономии места в листинге, чтобы он мог поместиться на один слайд презентации).

И последнее замечание: использовать системный вызов write так, как это делается в этих листингах, вообще говоря, нельзя, но об этих тонкостях тоже чуть позже (см.~\refsec{syscall:write}).

\section{Компиляция, линковка, динамическая загрузка и связанные с этим вещи}
\subsection{Объектные файлы}
В современном мире процесс превращения исходных кодов программы в её бинарное исполняемое представление (aka <<компиляция>>), в действительности состоит из двух этапов: компиляции и линковки.
Немного порассуждаем о первом процессе, дабы понять, зачем нужен второй.

Во время компиляции (в её <<классическом>> варианте) компилятор конкретного языка программирования преобразует исходные коды программы в опкоды (op-codes) конкретного процессора (aka <<бинарный код>>).
Если речь идёт о языках типа ассемблера или C, то полученный бинарный код для удобства дальнейшей с ним работы (как минимум в режиме отладки) должен быть очень похож на первоначальный исходный код, из которого его компилируют, в том смысле, что он точно также разбит на процедуры с такими же именами, что и в исходном варианте.
Поскольку процессор в своей работе использует исключительно адреса в памяти, а, например, отладчику нужны имена процедур (то есть строки), адреса которых лежат на стеке во время исполнения программы, то достаточно приложить к бинарному коду таблицу, сопоставляющую имена процедур их адресам, и все потребности обеих сторон будут удовлетворены.

Теперь, если вспомнить, что бывают не только сегменты кода с процедурами внутри, но и, например, сегменты данных, с которыми ассоциированы имена каких-то переменных (в программе на ассемблере этот факт заметнее, чем в программе на C), то было бы хорошо, чтобы все эти типы сегментов со всеми именами объектов в них можно было хранить вместе, но как-то различать.

\begin{definition}
Объектные файлы~--- форматы файлов, позволяющие хранить вместе различные сегменты, представляющие собой результаты компиляции одного элемента трансляции.
\end{definition}

Таким образом, в объектных файлах располагаются все сегменты программы и соответствующие им таблицы с именами.

До тех пор, пока содержимое объектного файла всегда располагается в памяти по адресу, известному на этапе компиляции, ничего лишнего для запуска этого кода делать не надо, поскольку все адреса в нём указывают куда следует.
Как только появляется желание размещать бинарный код программы <<где-то>> в памяти~--- сразу нужно что-то придумывать.

Самое наивное решение заключается в том, чтобы завести ещё одну табличку, которая сопоставляет в объектном файле всем инструкциям JMP, CALL, MOV и тому подобным имена процедур и переменных, на которые они ссылаются.

Не трудно предложить простой способ преобразования из объектных файлов в программы, которые можно запустить.
\begin{algorithm}\label{alg:link-simple}
    Алгоритм преобразования простых объектных файлов в код, который может исполнять процессор:
    \begin{itemize}
        \item договоримся о том, начиная с какого адреса в памяти будет располагаться программа;
        \item разместим значимое содержимое (не таблички с хозяйственной информацией, а только содержимое сегментов) объектного файла в памяти, начиная с этого адреса;
        \item пройдём по всем опкодам, делающими CALL, JMP или что-то подобное, и подставим в них настоящие адреса процедур, которые они вызывают (используя таблички имён процедур от сегментов кода и адрес начала программы);
        \item пройдём по всем опкодам, делающими MOV или как-то иначе работающими с ячейками памяти, и подставим в них настоящие адреса переменных, к которым они обращаются (снова используя соответствующие таблицы из объектного файла и адрес начала программы).
    \end{itemize}
\end{algorithm}

После этого преобразования можно передать управление на адрес начала программы и она должна начать корректно работать.

Внутри объектных файлов иногда бывает удобно разделить один сегмент на несколько секций, например, для того, чтобы один сегмент кода мог быть составлен из частей, имеющих осмысленные имена.
Например, в сегменте данных программы обычно присутствуют глобальные переменные, статические переменные, статические поля классов и другие тому подобные штуки.

\subsection{Линковка и динамическая загрузка}
\subsubsection{Статическая линковка}
Запасшись этими знаниями, рассмотрим два примера на языке C (листинги~\reflst{hipoteticTuA.c} и~\reflst{hipoteticTuB.c}).

\begin{ccode}{hipoteticTuA.c}
int foo()
{
    return 1;
}

int main()
{
    return foo();
}
\end{ccode}

\begin{ccode}{hipoteticTuB.c}
extern int foo();

int bar()
{
    return foo();
}
\end{ccode}

Договоримся, что каждый из этих двух файлов является отдельной единицей трансляции и они оба будут преобразованы в два разных объектных файла.
Заметим, что первая единица трансляции определяет две процедуры: foo и main, а вторая~--- одну процедуру bar.
При этом процедура main использует внутри себя foo, находящуюся в той же единице трансляции, а процедура bar использует foo, находящуюся в другой единице трансляции.

Преобразовать объектный файл, полученный из листинга~\reflst{hipoteticTuB.c}, в бинарный код по предложенному ранее алгоритму~\refalg{link-simple} уже не удастся, поскольку процедура foo находится вне этого объектного файла.
Зато не трудно реализовать алгоритм, который будет брать несколько объектных файлов и склеивать их в один большой (ресолвя перекрёстные ссылки на процедуры), который после этого можно преобразовывать в исполняемый код по алгоритму~\refalg{link-simple}.

В самом простом случае линковщик занимается именно этим: он берёт несколько объектных файлов и склеивает их одноимённые секции, проверяя, чтобы не возникало конфликтов (например, одноимённых процедур в разных объектных файлах), и чтобы у всех используемых процедур была реализация хотя бы в одном объектном файле.

Заметим, что теперь может оказаться полезной возможность указывать в таблице с процедурами внутри объектного файла является ли каждая конкретная процедура видимой снаружи данного объектного файла или нет (кстати, в коде на C требуемый эффект можно получить при помощи ключевого слова <<static>>).

\subsubsection{Динамическая линковка}
Теперь представьте, что процедура foo из листинга~\reflst{hipoteticTuA.c} настолько часто используется в разных программах, что разработчики решили вынести её в отдельную единицу трансляции, которую назвали <<программной библиотекой>>.
Со временем в эту программную библиотеку стали добавлять и другие полезные процедуры.
В результате, размер объектного файла у этой библиотеки стал больше суммы размеров всех объектных файлов среднестатистической программы.
Всё бы ничего, но при каждой линковке любой среднестатистической программы с этой прекрасной библиотекой, размер результирующего бинарника будет становится в два раза больше.
С учётом того, что обычно программа не использует все процедуры из библиотеки, то и вся библиотека обычно не нужна, но прилинковывать её придётся всё-таки всю.

Можно попытаться разделить большую библиотеку на несколько независимых поменьше, но, во-первых, это не всегда возможно, а, во-вторых, есть и другая проблема с предложенным типом линковки: если вдруг в библиотеке будет обнаружен баг, то, после его исправления, все программы, её использующие, придётся с ней как минимум перелинковывать, а то и целиком всё перекомпилировать.

Значит нужен какой-то более продвинутый метод линковки.
Заметим, что в этом продвинутом методе линковки просто склеивать все используемые объектные файлы нельзя, а нужно уметь линковаться с внешними объектными файлами, то есть объектные файлы должны уметь ссылаться на процедуры в других объектных файлах.
С другой стороны, поскольку теперь, при запуске программы, в память нужно загрузить несколько объектных файлов, а загружаемые объектные файлы, в свою очередь, тоже могут ссылаться на другие объектные файлы, то и метод загрузки должен стать несколько сложнее.

Таким образом, продвинутый метод линковки разваливается на два отдельных процесса:
\begin{itemize}
    \item саму линковку~--- склеиваются объектные файлы, которые можно склеить, и производятся проверки валидности вызовов между объектными файлами, которые не следует склеивать;
    \item и динамическую загрузку~--- связанные объектные файлы загружаются в память и между ними восстанавливаются нужные ссылки.
\end{itemize}

Ещё раз осмыслите всё то, что написано выше, и поедем дальше.

Представим себе, что всё содержимое всех объектных файлов, необходимых для работы программы, уже как-то разложено в памяти.
Для того, чтобы процедура, находящаяся в одном объектном файле, вызвала процедуру из другого объектного файла, первой из них нужен адрес второй.
Если разложение объектных файлов в памяти от одного запуска программы к другому может меняться (а обычно это именно так), то вычислить этот адрес заранее (на этапе линковки) невозможно.

Методы, доступные динамическому загрузчику для обхода этой неприятности, отличаются на различных архитектурах.
Например, на x$86_{32}$ отсутствует возможность длинной относительной адресации, и все адреса в инструкциях CALL должны быть абсолютными, поэтому после загрузки программы в память приходится пройтись по всем этим инструкциям и записать в них абсолютные адреса вызываемых процедур.
Точно также во все инструкции обращения к переменным следует записать их абсолютные адреса.

Если реализовывать это поведение <<в лоб>>, то при каждом запуске программы нужно выполнить уйму работы: для каждого вызова процедуры в каждом объектном файле нужно найти в остальных объектных файлах процедуру, на которую он ссылается, а потом ещё раз примерно тоже самое для общих глобальных переменных.
Попробуем что-то сэкономить, заметив, что:
\begin{itemize}
    \item число вызовов процедур всегда больше, чем число процедур, которые вызывают;
    \item аналогичное утверждение верно и для переменных;
    \item для ресолвинга вызовов и обращения к переменным, расположенным внутри текущего объектного файла, не нужно много работы.
\end{itemize}
Последнее утверждение может не казаться столь очевидным, как первые два.

На архитектурах с доступной длинной относительной адресацией (например, x$86_{64}$) для обращения к ресурсам текущего объектного файла вообще никакого ресолвинга не нужно, поскольку все относительные адреса можно вычислить на этапе компиляции.
На архитектурах без таких возможностей используется следующий трюк.
\begin{algorithm}\label{alg:link-sumload}
    Скомпилируем код так, как будто в памяти он будет расположен начиная с нулевого адреса. Тогда для того, чтобы при расположении кода в памяти, начиная с адреса $N$, сделать все адреса внутри инструкций в коде валидными, нужно просто к каждому адресу в каждой инструкции прибавить $N$.
\end{algorithm}
Таким образом, зная адрес начала объектного файла в памяти и список смещений (относительно начала этого объектного файла) всех интересующих нас адресов внутри инструкций JMP, CALL, MOV и тому подобных, не трудно (относительно) быстро сделать все локальные адреса валидными.

Код, скомпилированный таким образом, принято называть <<релокабельным>> (relocable), а процесс, описанный в алгоритме~\refalg{link-subload}~--- <<релокацией>>.

Но что делать с внешними вызовами?
Вспомнив предыдущие три пункта со свойствами обращений к памяти, нетрудно догадаться, что следует завести <<косвенную>> таблицу.

Для вызовов процедур в ней можно расположить инструкции JMP с абсолютными адресами внешних процедур, тогда вызов внешней процедуры внутри объектного файла будет выглядеть как вызов локальной процедуры по адресу ячейки с соответствующим JMP'ом в таблице, а адреса в самой таблице могут быть заполнены на этапе динамической загрузки.

Для обращений к общим глобальным переменным можно поступить аналогичным образом, с той разницей, что в таблице придётся хранить адреса переменных, а не инструкции для доступа к ним, а всю адресацию к этим переменным внутри объектного файла делать косвенной.

\begin{empdef}[inmemory](3cm, 3cm)
    boxjoin(a.ne=b.nw; a.se=b.sw)
    forsuffixes $=1,2,3:
        boxit.f$(btex JMP etex);
    endfor;
    boxit.f91();
    boxit.f11(btex ADDR etex);
    boxit.f12(btex ADDR etex);
    boxit.f92();
    boxit.f21(btex \dots DATA \dots etex);
    boxit.f93();
    boxit.f31(btex \dots etex);
    boxit.f32(btex \dots etex);
    boxit.f33(btex CALL etex);
    boxit.f34(btex CALL etex);
    boxit.f35(btex \dots etex);
    boxit.f37(btex CALL etex);
    boxit.f38(btex \dots etex);
    boxit.f39(btex CALL etex);
    boxit.f40(btex \dots etex);
    boxit.f42(btex CALL etex);

    boxjoin(a.ne=b.nw; a.se=b.sw)
    forsuffixes $=1,2:
        boxit.g$(btex JMP etex);
    endfor;
    boxit.g91();
    boxit.g11(btex ADDR etex);
    boxit.g92();
    boxit.g21(btex \dots DATA \dots etex);
    boxit.g93();
    forsuffixes $=31,32,33:
        boxit.g$(btex \dots etex);
    endfor;
    boxit.g34(btex CALL etex);
    forsuffixes $=35,36,37:
        boxit.g$(btex \dots etex);
    endfor;
    boxit.g38(btex CALL etex);
    boxit.g39(btex CALL etex);
    boxit.g40(btex CALL etex);
    boxit.g41(btex \dots etex);
    boxit.g42(btex CALL etex);
    boxit.g43(btex \dots etex);

    boxjoin(a.ne=b.nw; a.se=b.sw)
    boxit.h1(btex \dots etex);
    boxit.h2(btex \dots etex);
    boxit.h3(btex \dots etex);
    boxit.h4(btex CALL etex);
    boxit.h5(btex \dots etex);

    f1.c=(0,0);
    g1.c=(0,-2*h);
    h1.c=(3*w,-1*h);
    h1.n-h1.s=g1.n-g1.s;

    ahlength:=4;
    drawoptions(withcolor red);
    drawboxed(f1,f2,f3);
    drawunboxed(f91);
    drawboxed(f11,f12);
    drawunboxed(f92);
    drawoptions(withcolor black);
    drawboxed(f21);
    drawunboxed(f93);
    drawboxed(forsuffixes $=31,32,33,34,35,37,38,39,40: f$, endfor f42);
    drawoptions(withcolor red);
    drawboxed(g1,g2);
    drawunboxed(g91);
    drawboxed(g11);
    drawoptions(withcolor black);
    drawunboxed(g92);
    drawboxed(g21);
    drawunboxed(g93);
    drawboxed(forsuffixes $=31,32,33,34,35,36,37,38,39,40,41,42: g$, endfor g43);
    drawboxed(forsuffixes $=1,2,3,4: h$, endfor h5);
    drawarrow f33.n{up} .. f1.n;
    drawarrow f34.n{up} .. f3.n;
    drawarrow f37.n{up} .. f35.n;
    drawarrow f39.n{up} .. f2.n;
    drawarrow f42.n{up} .. f35.n;
    
    ahlength:=6;
    drawarrow h4.n{up} .. h1.n;

    ahlength:=4;
    drawarrow g34.s{down} .. g1.s;
    drawarrow g38.s{down} .. g2.s;
    drawarrow g39.s{down} .. g1.s;
    drawarrow g40.s{down} .. g36.s;
    drawarrow g42.s{down} .. g37.s;

    drawoptions(withcolor red);
    drawarrow f1.s{down} .. {down}g31.n;
    drawarrow f2.s{down} .. {down}h1.n;
    drawarrow f3.s{down} .. {down}g37.n;

    drawarrow g1.n{up} .. {up}f31.s;
    drawarrow g2.n{up} .. {up}h3.s;

    drawoptions(withcolor black dashed evenly);
    drawarrow f32.n{up} .. f11.n;
    drawarrow f38.n{up} .. f21.n;
    drawarrow f40.n{up} .. f21.n;
    drawarrow f40.n{up} .. f11.n;
    
    drawarrow g32.s{down} .. g11.s;
    drawarrow g35.s{down} .. g11.s;
    drawarrow g41.s{down} .. g21.s;

    drawoptions(withcolor red dashed evenly);
    drawarrow f11.s{down} .. {down}g21.n;
    drawarrow f12.s{down} .. {down}g21.n;
    
    drawarrow g11.n{up} .. {up}f21.s;
\end{empdef}

\drawfigureemp{inmemory}{Расположение трёх объектных файлов в памяти (с восстановленными при помощи динамического загрузчика связями). Пунктирными стрелками обозначены обращения к данным (глобальным переменным), сплошными~--- вызовы процедур. Красным выделено всё то, до чего не может не дотронуться динамический загрузчик.}

Пример возможного расположения в памяти трёх объектных файлов приведён на \reffig{inmemory}.
У первого и третьего объектного файлов изображены сегменты:
\begin{itemize}
    \item таблица внешних вызовов, где каждый <<JMP>>~--- ассемблерная инструкция JMP (с адресом, записанным туда динамическим загрузчиком);
    \item таблица внешних данных, где каждый <<ADDR>>~--- адрес внешних данных, записываемый в эту ячейку динамическим загрузчиком;
    \item сегмент данных (с, например, глобальными переменными);
    \item сегмент кода, где <<\dots>>~--- это какие-то ассемблерные инструкции, а <<CALL>>~--- ассемблерная инструкция CALL (заметим, что на архитектуре с доступной относительной адресацией динамический загрузчик может и не менять адреса внутри этих инструкций).
\end{itemize}
Таким образом, каждая ячейка, помеченная <<JMP>> или <<CALL>>, является одной ассемблерной инструкцией, а ячейки <<\dots DATA \dots>> и <<\dots>> могут содержать внутри целые промежутки с данными/исполняемым кодом.

Если множество объектных файлов с подключаемыми программными библиотеками в системе статично, и они все могут позволить себе при каждом запуске каждой программы располагаться по статическим адресам, то, вообще говоря, можно заранее вычислить адреса расположения в памяти для всех библиотек, применить к каждой из них алгоритм~\refalg{link-sumload}, и больше не делать этого при динамической загрузке.
Однако такие строгие условия в современных системах практически никогда не выполняются, а при первом же изменении множества программных библиотек всю работу придётся делать заново (не говоря уже о том, что на 32-x битной архитектуре может просто не хватить адресного  пространства для того, чтобы разместить в нём все доступные библиотеки).

Ещё раз осмыслите всё то, что написано выше, и поедем дальше.

Итого, типичный сценарий жизни обычной программы выглядит следующим образом:
\begin{itemize}
    \item компилируем: берём исходные коды, получаем объектные файлы;
    \item линкуем: склеиваем некоторые объектные файлы в один, а некоторые помечаем для динамического склеивания при загрузке;
    \item в результате получаем один или несколько объектных файлов, которые можно запускать (aka <<бинарники>>);
    \item при запуске бинарника, динамический загрузчик раскладывает в памяти все объектные файлы, от которых он зависит, а также объектные файлы, от которых зависят нужные этому объектному файлу объектные файлы, а также объектные файлы, от которых зависят объектные файлы, от которых зависят объектные файлы, нужные \dots и т.д.;
    \item если требуется, то ко всем адресам внутри объектного файла добавляется адрес его начала в памяти;
    \item динамический загрузчик восстанавливает все связи между объектными файлами, заполняя соответствующие таблички;
    \item управление передаётся загруженной программе.
\end{itemize}

Конечно, в принципе, от таблицы внешних вызовов можно было бы отказаться, если адреса внешних процедур хранить в таблице внешних данных, однако тогда вызовы процедур внутри кода объектного файла перестанут быть похожими на вызовы процедур, и, кроме того, перестанут работать некоторые полезные трюки (смотри \refsec{cl:linking:lazy}).
На практике же, в связи с тем, что таблицу внешних вызовов требуется размещать в исполняемом сегменте кода (а потому надо бы запретить её модифицировать), а вычисление абсолютных адресов внешних процедур может производиться не во время динамической загрузки, а откладываться (опять же смотри \refsec{cl:linking:lazy} ниже), в таблицу внешних данных помещают всё-таки и адреса внешних процедур.
После чего она приобретает название <<Global Offset Table>> (aka <<GOT>>).
Однако таблицу внешних вызовов, в отличие от предложения выше, не выкидывают, а размещают в ней косвенные JMPы по адресам, записанным в соответствующих ячейках GOT.
Сама такая таблица приобретает название <<Procedure Linkage Table>> (aka <<PLT>>).

Если теперь расстояние между PLT и GOT вычислить на этапе компиляции, то в ячейки PLT можно записывать адреса соответствующих ячеек GOT так, как это раньше делалось для релокабельного кода (представим, что объектный файл располагается в памяти с нулевого адреса \dots).
Таким образом, PLT также становится релокабельной, а <<умное>> заполнение на этапе динамической загрузки требуется только для GOT.

\subsubsection{PIC}
В реальной жизни, в целях повышения безопасности, часто применяется механизм рандомизации памяти, когда динамический загрузчик каждый объектный файл, по возможности, располагает в памяти по случайному адресу.
Очевидно, что при этом перестаёт работать кеширование заранее вычисленных адресов и другие подобные штуки.

Править только GOT (и PLT) при каждой загрузке объектника в память не есть очень затратно (поскольку обычно эти таблицы очень маленькие, и, кроме того, в системе с рандомизацией всё равно от них никуда не деться).
С другой стороны, суммирование адреса начала объектника почти с каждой его инструкцией (в реальных программах инструкции по работе с памятью встречаются очень часто)~--- занятие достаточно трудоёмкое.
Поэтому на время оставим таблички и посмотрим на код внутри каждого сегмента.

\begin{definition}
Placement Independent Code (PIC)~--- код, корректная работа которого не зависит от его расположения в памяти.
\end{definition}

Архитектуры с длинной относительной адресацией снова оказываются чертовски удобны, поскольку бинарный код для них без труда приводится к требованиям PIC и не требует релокации при загрузке.
С другой стороны, очевидно, что без какого-то аналога относительной адресации получить код, независимый от абсолютных адресов невозможно.
Возникает вопрос, а можно ли как-нибудь сэмулировать относительную адресацию на архитектуре, где таких возможностей нет?

Оказывается это не так уж и трудно сделать.
Рассмотрим следующий ассемблерный код, представленный на листинге~\reflst{pic.S}.

\begin{asmcode}{pic.S}
call foo
foo:
pop %eax
\end{asmcode}

Идея этого великого кусочка кода заключается в том, что, для того, чтобы такой код выполнить, на этапе динамической загрузки необходимо записать абсолютный адрес foo только в одну инструкцию CALL, а после исполнения этого кода в регистре eax оказывается абсолютный адрес текущей инструкции.
В рантайме же, имея абсолютный адрес одной инструкции и смещения от неё до всех других инструкций (вычисленные на этапе компиляции), можно вычислить абсолютный адрес любой другой инструкции.

Чтобы несколько упростить себе жизнь, связанную с этой арифметикой, как и ранее используется GOT, заполняемая на этапе динамической загрузки.
Тогда после получения адреса текущей инструкции (как в листинге~\reflst{pic.S}), вычисленный адрес GOT сохраняют в каком-то регистре (на x$86_{32}$~--- в ebx), после чего обращения ко всем переменным и процедурам (PLT обычно располагается рядом с GOT, а потому её адрес нетрудно вычислить имея адрес GOT) производятся через эти таблицы.
Заметим, что в отличие от не-PIC кода, в GOT теперь будут хранится не только внешние глобальные переменные и процедуры, как это было раньше, а вообще все переменные, не живущие на стеке или в регистрах, а также адреса всех процедур, в том числе и локальных.

Писать такой ассемблерный код руками весьма непросто, зато любому двухпроходному компилятору это прекрасно удаётся.

Весьма условная схема объектного файла, скомпилированного под PIC с поддержкой ленивой динамической линковки представлена на \reffig{pic}.

\begin{empdef}[pic](1, 1)
    boxjoin(a.ne=b.nw; a.se=b.sw)
    boxit.got(btex \dots GOT \dots etex);
    boxit.plt(btex \dots PLT \dots etex);

    boxit.f91();
    boxit.data(btex \dots DATA \dots etex);
    boxit.f92();
    boxit.f31(btex CALL etex);
    boxit.f32(btex . etex);
    boxit.f33(btex \dots etex);
    boxit.f34(btex CALL etex);
    boxit.f35(btex \dots etex);
    boxit.f36(btex \dots etex);
    boxit.f37(btex CALL etex);
    boxit.f38(btex \dots etex);

    drawoptions(withcolor red);
    drawboxed(got,plt);
    drawunboxed(f91);
    drawoptions(withcolor black);
    drawboxed(data);
    drawunboxed(f92);
    %drawboxed(f21);
    %drawunboxed(f93);
    drawoptions(withcolor red);
    drawboxed(f31);
    drawoptions(withcolor black);
    drawboxed(forsuffixes $=32,33,34,35,36,37: f$, endfor f38);

    drawoptions(withcolor red);
    drawarrow f31.n{up} .. {down}f32.n;
    drawoptions(withcolor black dashed evenly);
    drawarrow f33.s{down} .. {up}1/3[got.sw, got.se];
    drawoptions(withcolor red dashed evenly);
    drawarrow 1/3[got.nw, got.ne]{up} .. {down}data.n;
    drawoptions(withcolor black);
    drawarrow f34.s{down} .. {up}1/3[plt.sw, plt.se];
    drawoptions(withcolor red);
    drawarrow 1/3[plt.nw, plt.ne]{up} .. {down}f35.n;
    drawoptions(withcolor black);
    drawarrow f37.s{down} .. {up}2/3[plt.sw, plt.se];
    drawoptions(withcolor red);
    drawarrow 2/3[plt.nw, plt.ne]{up} .. {up}(1/2[got.n, f38.n]+(0,150pt));
\end{empdef}

\drawfigureemp{pic}{PIC в действии. Стрелкой <<в никуда>> обозначен внешний вызов}

В большинстве дистрибутивов GNU/Linux все shared-object'ы (программные библиотеки) компилируются в PIC.
В некоторых особенно параноидальных дистрибутивах даже обычные программы компилируются в PIC, чтобы вообще всё располагать по случайным адресам в памяти.

\subsubsection{Ленивость и другие забавные штуки}\label{sec:cl:linking:lazy}

Предложенная модель с выделенной GOT позволяет на этапе динамической загрузки подменять адреса переменных и процедур, к которым будет обращаться загружаемый объектный файл, на адреса не тех переменных и процедур, которые он запрашивает (поскольку заполнение GOT всецело находится в руках динамического загрузчика).
Сохранение выделенной PLT даже при условии того, что все адреса хранятся в GOT, также предоставляет немало свободы действий, поскольку если вместо одного JMP на нужный адрес размещать для каждого внешнего вызова в PLT несколько инструкций, то можно перед запуском требуемой процедуры делать разного рода забавные вещи.

Очевидно, то оба варианта игр с GOT и PLT могут нарушить нормальный порядок работы программы, однако их аккуратное использование может находить весьма удачные применения.
Например:
\begin{itemize}
    \item при загрузке объектного файла, можно все вызовы обёрток системных вызовов из стандартной библиотеки, работающих с сетью, заменить на вызовы процедур, прозрачно направляющих все запросы на какой-нибудь прокси-сервер (таким образом, для проксирования сетевого трафика отдельных программ (или даже всей системы) в самих программах ничего менять не нужно, кроме того, можно бесплатно получить централизованное конфигурирование сетевых настроек);
    \item весьма часто можно встретить подмену вызовов malloc и free на аналоги, ведущие статистику (для проверки кода на утечки памяти);
    \item в особо извращённых случаях вызовы типа fsync заменяют на заглушки, которые ничего не делают (повышает скорость работы программы, но, очевидно, всякие гарантии на согласованность данных на диске пропадают).
\end{itemize}
При использовании нескольких инструкций на элемент в PLT, дополнительные инструкции можно использовать для отладки (вставлять перед вызовом требуемой процедуры CALLы, производящие отладочные операции) или для ленивой динамической линковки.
На последнем остановимся подробнее.

Очень часто, при нормальном исполнении программы, некоторые внешние вызовы (например, процедуры вызываемые в обработчиках ошибок) вообще никогда не производятся, тем более не производится вызовов процедур, которые потенциально могут быть вызваны из процедур, которые сами не были вызваны, и так далее.
Поэтому иногда можно существенно сэкономить, если реализовать возможность ресолвинга адресов внешних процедур не при динамической загрузке объектного файла, а во время исполнения программы при первом обращении к запрашиваемой внешней процедуре.

Таким образом, идея ленивой линковки заключается в следующем:
\begin{itemize}
    \item при вызове записи из PLT проверяется, что адрес вызываемой внешней процедуры уже известен, после чего на него делается JMP;
    \item в случае, если адрес ещё не известен, то производится вызов процедуры динамического загрузчика (с идентификатором требуемого внешнего вызова в качестве параметра);
    \item динамический загрузчик находит абсолютный адрес требуемой процедуры, сохраняет его в месте, доступном проверке из PLT, после чего делает JMP на этот адрес.
\end{itemize}

В GNU/Linux для реализации динамической линковки, каждый элемент в PLT содержит три инструкции (листинг~\reflst{link-lazy-plt.S}):
\begin{itemize}
    \item JMP по адресу, записанному в соответствующей записи GOT (как отмечалось ранее, для каждой записи в PLT присутствует соответствующая запись с адресом процедуры в GOT);
    \item PUSH идентификатора требуемого вызова;
    \item JMP на процедуру динамического загрузчика.
\end{itemize}
Соответствующие элементы GOT изначально содержат адреса второй инструкции в соответствующей записи PLT (инструкция PUSH \dots).

\begin{asmcode}{link-lazy-plt.S}
jmp *GOT+n
push #offset
jmp DINLN
\end{asmcode}

Таким образом, при первом вызове первая инструкция записи в PLT сделает JMP на вторую инструкцию в этой же записи PLT.
Эта инструкция положит на стек адрес соответствующего поля в GOT, после чего следующая инструкция обратится к динамическому загрузчику.
При втором и последующих вызовах этой записи в PLT сразу будет произведён косвенный JMP на адрес необходимой процедуры.

Ещё раз осмыслите всё то, что написано выше, и поедем дальше.

\subsubsection{Типы линковки}
Классифицируя упомянутые выше методы можно выделить следующие типы линковки:
\begin{itemize}
    \item статическая~--- когда несколько объектных файлов склеиваются в один;
    \item динамическая~--- когда собственно восстановление ссылок переносится на этап динамической загрузки, этот тип в свою очередь подразделяется на:
        \begin{itemize}
            \item модификация всех адресов в инструкциях прямо в коде;
            \item GOT, релоцируемая PLT, релоцируемый код;
            \item GOT, релоцируемая PLT, PIC;
            \item GOT, релоцируемая PLT, релоцируемый код, ленивая динамическая загрузка;
            \item GOT, релоцируемая PLT, PIC, ленивая динамическая загрузка;
            \item GOT, относительная PLT, бесплатный PIC (на архитектурах с длинной относительной адресацией);
            \item GOT, относительная PLT, бесплатный PIC, ленивая динамическая загрузка (на архитектурах с длинной относительной адресацией);
        \end{itemize}
    \item статическая линковка динамических объектов.
\end{itemize}

Последний тип линковки представляет собой вариант динамической линковки с кешированием, когда все объектные файлы всегда располагаются по статическим адресам в памяти. Однако, опять же, стоит только одному из этих файлов измениться, как все объектные файлы всей системы нужно будет перелинковать.

\subsection{ELF}
Исторически существовало (а где-то существует и до сих пор) множество различных форматов объектных и исполняемых файлов.
На сегодняшний день самыми распространёнными являются: COFF, PE и ELF, однако тенденция к унификации медленно движет мир в сторону последнего, поскольку он поддерживается на почти всех распространённых архитектурах, но, в тоже время, является достаточно простым внутри.
Приятным преимуществом ELF перед некоторыми другими форматами является то, что в него <<умещаются>>:
\begin{itemize}
    \item объектные файлы, используемые во время компиляции и линковки;
    \item результирующие бинарные файлы;
    \item файлы программных библиотек;
\end{itemize}
в то время как у многих других форматов внутренняя структура этих типов объектных файлов сильно различается.
Кроме того, с 1999 года ELF является стандартом объектных и исполняемых файлов UNIX-like систем для x86.

Внутренняя структура ELF (который, кстати, расшифровывается как <<Executable and Linkable Format>>) файла представлена на \reffig{elf}.
После заголовка ELF со всякой хозяйственной информацией следует таблица сегментов (aka <<segments table>>, <<program header table>>).
Сразу за этой таблицей начинается <<тело>> ELF, за которым может располагаться таблица секций.
Последняя таблица \emph{может располагаться} по той причине, что она, по большому счёту, нужна только линковщику, а потому (в целях экономии места) может быть почти безболезненно отрезана от ELF исполняемого бинарника.

\begin{empdef}[elf](1, 1)
    boxjoin(a.sw=b.nw; a.se=b.ne)
    boxit.h(btex ELF header etex);
    boxit.p(btex Segments table etex);
    boxit.sp1();
    boxit.i(btex .init etex);
    boxit.t(btex .text etex);
    boxit.f(btex .fini etex);
    boxit.r(btex .rodata etex);
    boxit.dts(btex \dots etex);
    boxit.d(btex .data etex);
    boxit.b(btex .bss etex);
    boxit.sp2();
    boxit.s(btex Sections table etex);
    h.c=(0,0);
    h.dx=10;
    drawboxed(h,p);
    drawunboxed(sp1);
    drawboxed(i,t,f,r);
    drawunboxed(dts);
    drawboxed(d,b);
    drawunboxed(sp2);
    drawboxed(s);

    picture sego; sego=thelabel.lft(btex $\lbrace$ etex xscaled 2 yscaled 5, 1/2[i.nw,r.sw]);
    picture segt; segt=thelabel.lft(btex $\lbrace$ etex xscaled 2 yscaled 3, 1/2[d.nw,b.sw]);

    forsuffixes $=sego,segt:
        draw $;
        drawarrow p.w{left} .. {right}1/2[ulcorner $, llcorner $];
    endfor;

    forsuffixes $=i,t,f,r,d,b:
        drawarrow s.e{right} .. {left}$.e;
    endfor;
\end{empdef}

\drawfigureemp{elf}{Внутренняя структура ELF}

Таблица сегментов состоит из строк, каждая из которых описывает один сегмент.
Описание сегмента содержит (приводятся интересующие нас далее поля):
\begin{itemize}
    \item тип сегмента;
    \item смещение относительно начала тела ELF;
    \item адрес в виртуальном адресном пространстве, по которому этот сегмент нужно будет разместить;
    \item адрес в физическом адресном пространстве, по которому этот сегмент нужно будет разместить;
    \item размер сегмента в ELF;
    \item размер сегмента в памяти;
    \item флаги.
\end{itemize}

Например, для /bin/bash эта таблица имеет вид, представленный в листинге~\reflst{bash-elf-segments}.
\begin{stdout}{bash-elf-segments}{Сегменты ELF /bin/bash}
Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
PHDR           0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4
INTERP         0x000134 0x08048134 0x08048134 0x00013 0x00013 R   0x1
    [Requesting program interpreter: /lib/ld-linux.so.2]
LOAD           0x000000 0x08048000 0x08048000 0xbd674 0xbd674 R E 0x1000
LOAD           0x0bd674 0x08106674 0x08106674 0x04790 0x0959c RW  0x1000
DYNAMIC        0x0bd688 0x08106688 0x08106688 0x000e0 0x000e0 RW  0x4
NOTE           0x000148 0x08048148 0x08048148 0x00044 0x00044 R   0x4
GNU_EH_FRAME   0x0bd5b8 0x081055b8 0x081055b8 0x0002c 0x0002c R   0x4
GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
\end{stdout}

Таблица секций похожа на таблицу сегментов, но с несколько более сложной структурой, содержащей (снова приводятся только интересующие нас далее поля):
\begin{itemize}
    \item имя секции;
    \item тип секции;
    \item адрес в виртуальном адресном пространстве;
    \item смещение относительно начала тела ELF;
    \item размер секции.
\end{itemize}

Для /bin/bash эта таблица имеет вид, представленный в листинге~\reflst{bash-elf-sections}.
\begin{stdout}{bash-elf-sections}{Секции ELF /bin/bash (отрывок)}
[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
[ 0]                   NULL            00000000 000000 000000 00      0   0  0
[ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1
[ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4
[ 3] .note.gnu.build-i NOTE            08048168 000168 000024 00   A  0   0  4
[ 4] .hash             HASH            0804818c 00018c 0040c4 04   A  6   0  4
[ 5] .gnu.hash         GNU_HASH        0804c250 004250 0035f0 04   A  6   0  4
[ 6] .dynsym           DYNSYM          0804f840 007840 0082a0 10   A  7   1  4
[ 7] .dynstr           STRTAB          08057ae0 00fae0 007e94 00   A  0   0  1
[ 8] .gnu.version      VERSYM          0805f974 017974 001054 02   A  6   0  2
[ 9] .gnu.version_r    VERNEED         080609c8 0189c8 0000a0 00   A  7   2  4
[10] .rel.dyn          REL             08060a68 018a68 000040 08   A  6   0  4
[11] .rel.plt          REL             08060aa8 018aa8 0005c8 08   A  6  13  4
[12] .init             PROGBITS        08061070 019070 000030 00  AX  0   0  4
[13] .plt              PROGBITS        080610a0 0190a0 000ba0 04  AX  0   0  4
[14] .text             PROGBITS        08061c40 019c40 08a1ac 00  AX  0   0 16
[15] .fini             PROGBITS        080ebdec 0a3dec 00001c 00  AX  0   0  4
[16] .rodata           PROGBITS        080ebe20 0a3e20 019798 00   A  0   0 32
\end{stdout}

Таким образом, и сегменты, и секции указывают на отрезки внутри объектного файла в формате ELF.
Обычно подразумевается, что каждый сегмент содержит в себе несколько секций целиком, но на практике одна секция может пересекать несколько сегментов сразу.

Именование файлов в ELF формате, в принципе, ничем не ограничено, но для промежуточных объектных файлов, генерируемых в процессе компиляции принято использовать расширение <<.o>>, а программные библиотеки размещать в файлах с именами начинающимися на <<lib>> и с расширением <<.so>>.

\subsection{Секции и сегменты}
%TODO:
Тут будет от интерпретации представленных выше структур.

\subsection{Линковка}
%TODO:
Тут будет о линковке ELFок. В данный момент очень вяло написано.

Всё это очень интересно, но что всё же собственно делает линковщик с объектными файлами в формате ELF?
Оказывается, он просто склеивает одноимённые секции в объектных файлах, линкуемых статически и проверяет корректность внешних вызовов к объектным файлам, линкуемым динамически.

При этом порядок, в котором будут склеены объектные файлы, вообще говоря, имеет значение.
Например, существует несколько стандартных объектных файлов, статически прилинковываемых (почти) к любой программе:
\begin{itemize}
    \item crti.o~--- содержит определения процедур \_init и \_fini;
    \item crtbegin.o и crtend.o~--- (для С++) добавляют в тела процедур \_init и \_fini вызовы глобальных конструкторов и деструкторов соответственно;
    \item crtn.o~--- содержит инструкции RET для процедур \_init и \_fini.
\end{itemize}
Для каждого объектного файла динамический загрузчик, после размещения объектного файла в памяти, но до запуска процедуры \_start, вызывает процедуру \_init (если она определена).
Линковка объектных файлов программы с этими объектными файлами требует определённого порядка: crti, crtbegin, объектные файлы программы, crtend, crtn.

\subsection{Динамический загрузчик}
Снова вспомним, что, не смотря на всю внешнюю простоту происходящего, в запуске объектного файла участвуют трое:
\begin{itemize}
    \item пользователь, который его запускает, то есть, например, я (а вернее~--- некоторая программа от моего имени), набирая в консоли <</bin/bash>>;
    \item ядро, которому приходится обрабатывать системный вызов exec с <</bin/bash>> в качестве какого-то параметра;
    \item и, внимание, \emph{динамический загрузчик}, который будет вызван ядром, которому очень хочется обработать exec с <</bin/bash>> в качестве какого-то параметра, но не очень хочется разбираться во всех этих премудростях из сегментов, секций, программных библиотек, PIC и тому подобного.
\end{itemize}

Иначе говоря, после того, как ядро разберётся в том, что его просят запустить, и в том, можно ли это запустить, вместо того, чтобы самостоятельно разбираться во всех возможных сценариях запуска программы, оно запускает динамический загрузчик, каким-то образом указывая ему на нужный ELF (передаёт путь к файлу в качестве аргумента argv или передаёт открытый файловый дескриптор, связанный с ним).
Поскольку сам динамический загрузчик является программой в ELF, то ядру всё-таки приходится что-то понимать во внутренностях этого формата, однако класс ELF'ок, которые способно загрузить ядро, очень ограничен.

Итого, в UNIX-like системах на самом деле обычно есть \emph{два} динамических загрузчика: один в ядре, и ещё один в юзерспейсе.
Причём сил первого достаточно на очень простые ELF'ки, а второй умеет очень много, хотя сам он скомпилирован в простую ELF'ку.

Не смотря на то, что в ядре тоже есть кусок кода, выполняющий роль динамического загрузчика, когда говорят <<динамический загрузчик>> обычно подразумевают именно второй.

В GNU/Linux динамический загрузчик располагается в файловой системе по адресу\\<</lib/ld-linux.so.\$mversion>>, где <<\$mversion>>~--- мажорный номер его версии.
Этот файл, в свою очередь, может являться симлинком на что-то вроде <</lib/ld-\$version.so>>, где <<\$version>>~--- полный номер версии загрузчика.

При загрузке объектных файлов ld-linux ищет связанные объектные файлы (библиотеки) в директориях <</lib>>, <</usr/lib>> и <</usr/local/lib>> в соответствующем порядке.
Если по каким-то причинам этот порядок нужно изменить или добавить туда ещё какую-то директорию, то в окружение следует добавить переменную <<LD\_LIBRARY\_PATH>> со значением, содержащим необходимые пути, перечисленные через запятую.
Тогда динамический загрузчик заглядывает в пути, указанные в этой переменной, а уже потом идёт по стандартным.

\section{Практика}
%TODO
Тут будет о том как делать .so, вызывать динамический линковщик в райнтайме, делать программы с плугинами и другие интересные вещи.

\section{Комментарии}
%TODO вопрос: объектный файл - бинарник - библиотека, relocable code
Из текста не совсем понятно соотношение между <<объектными файлам>>, <<бинарниками>> и <<программными библиотеками>>.
Автору не совсем понятно как это понятно объяснить, ибо границы размыты.

\section{Краткое содержание}
%TODO
Тут будет краткое содержание написанного выше.
